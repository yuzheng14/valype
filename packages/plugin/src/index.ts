import type {
  UnpluginFactory,
  TransformResult as UnTransformResult,
} from 'unplugin'
import type { Options } from './types'
import { createUnplugin } from 'unplugin'
import { generate } from 'valype'
import MagicString from 'magic-string'
import { readFile } from 'node:fs/promises'
import { createRequire } from 'node:module'

/** regular expression match all virtual module generated by this plugin */
const virtualModuleRE = /^valype:/
// go's regex library doesn't support negative lookahead, so we use `[^v]` instead.
/** regular expression match all *.valype.ts written by user */
const valypeModuleRE = /^[^v].*\.valype\.ts$/

type TransformResult = Exclude<UnTransformResult, string>

export const unpluginFactory: UnpluginFactory<Options | undefined> = () => {
  // cache for generated schemas
  const schemaCache = new Map<string, string>()
  // cache for content of transformed `*.valype.ts` files
  const contentCache = new Map<string, TransformResult>()

  async function loadValypeFileContent(id: string): Promise<TransformResult> {
    if (contentCache.has(id)) {
      return contentCache.get(id)!
    }

    const code = await readFile(id, 'utf-8')
    const result = await generate(code)
    if (result.code && result.exports.length > 0) {
      schemaCache.set(
        id,
        result.code + '\nexport { type ZodIssue } from "zod/v4"\n',
      )
      const s = new MagicString(code)
      s.prepend(
        `import { ${result.exports.map((e) => e.schema).join(', ')}, type ZodIssue } from 'valype:${id}'\n`,
      )
      s.append('\n')
      s.append(
        result.exports
          .map(
            (e) =>
              `export function validate${e.interface}(data: unknown): ZodIssue[] | undefined {
  const result = ${e.schema}.safeParse(data)
  return result.error?.issues
            }`,
          )
          .join('\n'),
      )
      s.append('\n')
      const transformed: TransformResult = {
        code: s.toString(),
        map: s.generateMap({
          source: id,
          includeContent: true,
          hires: 'boundary',
        }),
      }
      contentCache.set(id, transformed)
      return transformed
    }
  }

  function loadVirtualModule(id: string): string | Error {
    const realId = id.slice('valype:'.length)
    const code = schemaCache.get(realId)
    if (!code) {
      return Error(`Cannot find schema for ${realId}`)
    }
    return code
  }

  return {
    name: 'unplugin-valype',
    // FIXME because we need to resolve `zod/v4` before `vite:resolve`,
    // we need to enforce this plugin to run before `vite:resolve` plugin.
    // After adapter mechanism is implemented, we can remove this.
    enforce: 'pre',
    resolveId: {
      filter: { id: [virtualModuleRE, /^zod\/v4$/] },
      handler(id, importer) {
        if (virtualModuleRE.test(id)) return id
        // FIXME temporarily we need to point `zod/v4` to self-hosted zod,
        // after adapter mechanism we can remove this.
        else if (importer && virtualModuleRE.test(importer)) {
          const require = createRequire(import.meta.url)
          const path =
            require.resolve('zod/v4').split('node_modules')[0] +
            'node_modules/zod/dist/esm/v4/index.js'
          console.log(`path ==>`, path)
          return path
        }
      },
    },
    load: {
      filter: { id: [virtualModuleRE, valypeModuleRE] },
      async handler(id) {
        if (virtualModuleRE.test(id)) {
          const result = loadVirtualModule(id)
          if (result instanceof Error) {
            this.error(result.message)
          } else return result
        } else if (valypeModuleRE.test(id)) {
          return loadValypeFileContent(id)
        }
      },
    },
    // there is no need to use cache after build, so we can clear it to free memory
    buildEnd() {
      schemaCache.clear()
      contentCache.clear()
    },
    // vite use esbuild to optimize(pre-bundle) dependencies, in this process,
    // it will scan all dependencies used in source code,
    // but it doesn't use this plugin. So that it will not find schema generated by this plugin,
    // and report an error which says `No matching export in "src/*.valype.ts" for import "*Schema"`.
    // Therefore, we need to add a plugin to esbuild to handle `*.valype.ts` files.
    vite: {
      config() {
        return {
          optimizeDeps: {
            esbuildOptions: {
              plugins: [
                {
                  name: 'unplugin-valype/deps-optimization',
                  setup(build) {
                    build.onLoad({ filter: valypeModuleRE }, async (args) => {
                      const result = await loadValypeFileContent(args.path)
                      if (result) {
                        return {
                          contents: result.code,
                          loader: 'ts',
                        }
                      }
                    })
                    build.onResolve({ filter: virtualModuleRE }, (args) => {
                      return { path: args.path, namespace: 'ts' }
                    })
                    build.onLoad({ filter: virtualModuleRE }, async (args) => {
                      const code = loadVirtualModule(args.path)
                      if (code instanceof Error) throw code
                      return {
                        contents: code,
                        loader: 'ts',
                      }
                    })
                  },
                },
              ],
            },
          },
        }
      },
    },
  }
}

export const unplugin = /* #__PURE__ */ createUnplugin(unpluginFactory)

export default unplugin
