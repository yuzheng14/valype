import type {
  UnpluginFactory,
  TransformResult as UnTransformResult,
} from 'unplugin'
import type { Options } from './types'
import { createUnplugin } from 'unplugin'
import {
  generate,
  ValypeReferenceError,
  ValypeSyntaxError,
  ValypeUnimplementedError,
} from 'valype'
import MagicString from 'magic-string'
import { readFile } from 'node:fs/promises'
import { v7 } from 'uuid'
import { basename } from 'node:path'

/** regular expression match all virtual module generated by this plugin */
const virtualModuleRE = /^valype:/
// go's regex library doesn't support negative lookahead, so we use `[^v]` instead.
/** regular expression match all *.valype.ts written by user */
const valypeModuleRE = /^[^v].*\.valype\.ts$/

type TransformResult = Exclude<UnTransformResult, string>

// copy from sourcecode of vite
interface Pos {
  /** 1-based */
  line: number
  /** 0-based */
  column: number
}
const splitRE = /\r?\n/g
// performance optimized version of vite, besides offset will be set to source.length when overlong
export function numberToPos(source: string, offset: number | Pos): Pos {
  if (typeof offset !== 'number') return offset
  if (offset > source.length) {
    offset = source.length
  }

  const lines = source.slice(0, offset).split(splitRE)
  return {
    line: lines.length,
    column: lines[lines.length - 1].length,
  }
}

export const unpluginFactory: UnpluginFactory<Options | undefined> = () => {
  // cache for generated schemas
  const schemaCache = new Map<string, string>()
  // cache for content of transformed `*.valype.ts` files
  const contentCache = new Map<string, TransformResult>()

  async function loadValypeFileContent(id: string): Promise<
    | TransformResult
    | ((ValypeReferenceError | ValypeUnimplementedError | ValypeSyntaxError) & {
        code: string
      })
  > {
    if (contentCache.has(id)) {
      return contentCache.get(id)!
    }

    const code = await readFile(id, 'utf-8')
    const result = await generate(code)
    if (result instanceof Error) return Object.assign(result, { code })
    if (result.code.content && result.exports.length > 0) {
      // Windows-style path will be escaped in import path,
      // so use formal of uuid v7 + basename as id of virtual module
      const virtualId = v7() + basename(id)
      schemaCache.set(
        virtualId,
        result.code.banner +
          '\n' +
          result.code.imports.join('\n') +
          '\n' +
          result.code.content +
          '\nexport { type $ZodIssue } from "zod/v4/core"\n',
      )
      const s = new MagicString(code)
      s.prepend(
        `import { ${result.exports.map((e) => e.schema).join(', ')}, type $ZodIssue } from 'valype:${virtualId}'\n`,
      )
      s.append('\n')
      s.append(
        result.validatorImport +
          '\n' +
          result.exports
            .map((e) => {
              const exports = result.generateValidator(e.interface, e.schema)
              return [
                exports.banner,
                exports.imports.join('\n'),
                exports.content,
              ].join('\n')
            })
            .join('\n'),
      )
      s.append('\n')
      const transformed: TransformResult = {
        code: s.toString(),
        map: s.generateMap({
          source: id,
          includeContent: true,
          hires: 'boundary',
        }),
      }
      contentCache.set(id, transformed)
      return transformed
    }
  }

  function loadVirtualModule(id: string): string | Error {
    const realId = id.slice('valype:'.length)
    const code = schemaCache.get(realId)
    if (!code) {
      return Error(`Cannot find schema for ${realId}`)
    }
    return code
  }

  return {
    name: 'unplugin-valype',
    // FIXME because we need to resolve `zod/v4` before `vite:resolve`,
    // we need to enforce this plugin to run before `vite:resolve` plugin.
    // After adapter mechanism is implemented, we can remove this.
    enforce: 'pre',
    resolveId: {
      filter: { id: [virtualModuleRE] },
      handler(id) {
        return id
      },
    },
    load: {
      filter: { id: [virtualModuleRE, valypeModuleRE] },
      async handler(id) {
        if (virtualModuleRE.test(id)) {
          const result = loadVirtualModule(id)
          if (result instanceof Error) this.error(result.message)
          else return result
        } else if (valypeModuleRE.test(id)) {
          const result = await loadValypeFileContent(id)
          if (result instanceof Error)
            this.error({
              message: result.message,
              loc: numberToPos(result.code, result.span.start),
            })
          else return result
        }
      },
    },
    // there is no need to use cache after build, so we can clear it to free memory
    buildEnd() {
      schemaCache.clear()
      contentCache.clear()
    },
    // vite use esbuild to optimize(pre-bundle) dependencies, in this process,
    // it will scan all dependencies used in source code,
    // but it doesn't use this plugin. So that it will not find schema generated by this plugin,
    // and report an error which says `No matching export in "src/*.valype.ts" for import "*Schema"`.
    // Therefore, we need to add a plugin to esbuild to handle `*.valype.ts` files.
    vite: {
      config() {
        return {
          optimizeDeps: {
            esbuildOptions: {
              plugins: [
                {
                  name: 'unplugin-valype/deps-optimization',
                  setup(build) {
                    build.onLoad({ filter: valypeModuleRE }, async (args) => {
                      const result = await loadValypeFileContent(args.path)
                      if (result instanceof Error)
                        return { errors: [{ text: result.message }] }
                      else if (result)
                        return {
                          contents: result.code,
                          loader: 'ts',
                        }
                    })
                    build.onResolve({ filter: virtualModuleRE }, (args) => {
                      return { path: args.path, namespace: 'ts' }
                    })
                    build.onLoad({ filter: virtualModuleRE }, async (args) => {
                      const code = loadVirtualModule(args.path)
                      if (code instanceof Error) throw code
                      return {
                        contents: code,
                        loader: 'ts',
                      }
                    })
                  },
                },
              ],
            },
          },
        }
      },
    },
  }
}

export const unplugin = /* #__PURE__ */ createUnplugin(unpluginFactory)

export default unplugin
