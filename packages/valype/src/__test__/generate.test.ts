import { generate } from '../generate'
import { describe, it, expect } from 'vitest'

// FIXME test case has been increasingly unmaintainable

describe('generate function', () => {
  it('should convert interface with type keyword to zod schema', async () => {
    const code = `
      export interface User {
        uid: symbol
        name: string
        age: number
        isActive: boolean
        balance: bigint
        superpower: undefined
        lastLogin: null
        metadata: any
        preferences: unknown
        logout: void
        neverField: never
      }
    `

    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "export const UserSchema = z.object({
        uid: z.symbol(),
        name: z.string(),
        age: z.number(),
        isActive: z.boolean(),
        balance: z.bigint(),
        superpower: z.undefined(),
        lastLogin: z.null(),
        metadata: z.any(),
        preferences: z.unknown(),
        logout: z.void(),
        neverField: z.never(),
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "User",
            "schema": "UserSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateUser(data: unknown): $ZodIssue[] | undefined {
          const result = UserSchema.safeParse(data)
          return result.error?.issues
        }

        export function isUser(data: unknown): data is User {
          return validateUser(data) === undefined
        }

        export function assertUser(data: unknown): asserts data is User {
          const issues = validateUser(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should have no exports', async () => {
    const code = `
      interface Tel {
        areaCode?: string | null
        tel: string | undefined
      }
    `
    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "",
          "content": "",
          "imports": [],
        },
        "exports": [],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`""`)
    }
  })

  it('should handle interfaces with union type property', async () => {
    const code = `
      interface Tel {
        areaCode?: string | null
        tel: string | undefined
      }

      export interface User {
        tel: Tel | string | null
      }
    `

    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "const TelSchema = z.object({
        areaCode: z.union([z.string(), z.null()]).optional(),
        tel: z.union([z.string(), z.undefined()]),
      })

      export const UserSchema = z.object({
        tel: z.union([TelSchema, z.string(), z.null()]),
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "User",
            "schema": "UserSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateUser(data: unknown): $ZodIssue[] | undefined {
          const result = UserSchema.safeParse(data)
          return result.error?.issues
        }

        export function isUser(data: unknown): data is User {
          return validateUser(data) === undefined
        }

        export function assertUser(data: unknown): asserts data is User {
          const issues = validateUser(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle optional properties', async () => {
    const code = `
      export interface Product {
        id: string
        name?: string
        price: number
      }
    `

    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "export const ProductSchema = z.object({
        id: z.string(),
        name: z.string().optional(),
        price: z.number(),
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "Product",
            "schema": "ProductSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateProduct(data: unknown): $ZodIssue[] | undefined {
          const result = ProductSchema.safeParse(data)
          return result.error?.issues
        }

        export function isProduct(data: unknown): data is Product {
          return validateProduct(data) === undefined
        }

        export function assertProduct(data: unknown): asserts data is Product {
          const issues = validateProduct(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle array types', async () => {
    const code = `
      export interface Order {
        items: string[];
        quantities: number[];
      }
    `

    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "export const OrderSchema = z.object({
        items: z.array(z.string()),
        quantities: z.array(z.number()),
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "Order",
            "schema": "OrderSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateOrder(data: unknown): $ZodIssue[] | undefined {
          const result = OrderSchema.safeParse(data)
          return result.error?.issues
        }

        export function isOrder(data: unknown): data is Order {
          return validateOrder(data) === undefined
        }

        export function assertOrder(data: unknown): asserts data is Order {
          const issues = validateOrder(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle nested interfaces', async () => {
    const code = `
      export interface Address {
        street: string
        city: string
      }

      export interface Person {
        name: string
        address: Address
      }
    `

    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "export const AddressSchema = z.object({
        street: z.string(),
        city: z.string(),
      })

      export const PersonSchema = z.object({
        name: z.string(),
        address: AddressSchema,
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "Address",
            "schema": "AddressSchema",
          },
          {
            "interface": "Person",
            "schema": "PersonSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateAddress(data: unknown): $ZodIssue[] | undefined {
          const result = AddressSchema.safeParse(data)
          return result.error?.issues
        }

        export function isAddress(data: unknown): data is Address {
          return validateAddress(data) === undefined
        }

        export function assertAddress(data: unknown): asserts data is Address {
          const issues = validateAddress(data)
          if (issues) throw issues
        }


        export function validatePerson(data: unknown): $ZodIssue[] | undefined {
          const result = PersonSchema.safeParse(data)
          return result.error?.issues
        }

        export function isPerson(data: unknown): data is Person {
          return validatePerson(data) === undefined
        }

        export function assertPerson(data: unknown): asserts data is Person {
          const issues = validatePerson(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle extended interfaces', async () => {
    const code = `
      export interface Id {
        id: string
      }

      export interface Name {
        name: string
      }

      export interface IdName extends Id, Name {}

      export interface User extends IdName {
        name: string
        age: number
      }
    `

    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "export const NameSchema = z.object({
        name: z.string(),
      })

      export const IdSchema = z.object({
        id: z.string(),
      })

      export const IdNameSchema = z.object({
        ...IdSchema.shape,
        ...NameSchema.shape,
      })

      export const UserSchema = z.object({
        ...IdNameSchema.shape,
        name: z.string(),
        age: z.number(),
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "Id",
            "schema": "IdSchema",
          },
          {
            "interface": "Name",
            "schema": "NameSchema",
          },
          {
            "interface": "IdName",
            "schema": "IdNameSchema",
          },
          {
            "interface": "User",
            "schema": "UserSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateId(data: unknown): $ZodIssue[] | undefined {
          const result = IdSchema.safeParse(data)
          return result.error?.issues
        }

        export function isId(data: unknown): data is Id {
          return validateId(data) === undefined
        }

        export function assertId(data: unknown): asserts data is Id {
          const issues = validateId(data)
          if (issues) throw issues
        }


        export function validateName(data: unknown): $ZodIssue[] | undefined {
          const result = NameSchema.safeParse(data)
          return result.error?.issues
        }

        export function isName(data: unknown): data is Name {
          return validateName(data) === undefined
        }

        export function assertName(data: unknown): asserts data is Name {
          const issues = validateName(data)
          if (issues) throw issues
        }


        export function validateIdName(data: unknown): $ZodIssue[] | undefined {
          const result = IdNameSchema.safeParse(data)
          return result.error?.issues
        }

        export function isIdName(data: unknown): data is IdName {
          return validateIdName(data) === undefined
        }

        export function assertIdName(data: unknown): asserts data is IdName {
          const issues = validateIdName(data)
          if (issues) throw issues
        }


        export function validateUser(data: unknown): $ZodIssue[] | undefined {
          const result = UserSchema.safeParse(data)
          return result.error?.issues
        }

        export function isUser(data: unknown): data is User {
          return validateUser(data) === undefined
        }

        export function assertUser(data: unknown): asserts data is User {
          const issues = validateUser(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle interfaces unexported', async () => {
    const code = `
    interface Id {
      id: string
    }
    
    interface Name {
      name: string
    }
    
    export interface User extends Name {
      age: number
    }
    `

    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "const NameSchema = z.object({
        name: z.string(),
      })

      export const UserSchema = z.object({
        ...NameSchema.shape,
        age: z.number(),
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "User",
            "schema": "UserSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateUser(data: unknown): $ZodIssue[] | undefined {
          const result = UserSchema.safeParse(data)
          return result.error?.issues
        }

        export function isUser(data: unknown): data is User {
          return validateUser(data) === undefined
        }

        export function assertUser(data: unknown): asserts data is User {
          const issues = validateUser(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle interfaces have literal types', async () => {
    const code = `
    export interface User {
      name: {
        first: string
        last: string
      }
      age: number
    }
    `
    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "export const UserSchema = z.object({
        name: z.object({
        first: z.string(),
        last: z.string(),
      }),
        age: z.number(),
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "User",
            "schema": "UserSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateUser(data: unknown): $ZodIssue[] | undefined {
          const result = UserSchema.safeParse(data)
          return result.error?.issues
        }

        export function isUser(data: unknown): data is User {
          return validateUser(data) === undefined
        }

        export function assertUser(data: unknown): asserts data is User {
          const issues = validateUser(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle simple type alias', async () => {
    const code = `
    export type Age = number
    export type Gender = 'male' | 'female'
    `
    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "export const GenderSchema = z.union([z.literal('male'), z.literal('female')])

      export const AgeSchema = z.number()

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "Age",
            "schema": "AgeSchema",
          },
          {
            "interface": "Gender",
            "schema": "GenderSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateAge(data: unknown): $ZodIssue[] | undefined {
          const result = AgeSchema.safeParse(data)
          return result.error?.issues
        }

        export function isAge(data: unknown): data is Age {
          return validateAge(data) === undefined
        }

        export function assertAge(data: unknown): asserts data is Age {
          const issues = validateAge(data)
          if (issues) throw issues
        }


        export function validateGender(data: unknown): $ZodIssue[] | undefined {
          const result = GenderSchema.safeParse(data)
          return result.error?.issues
        }

        export function isGender(data: unknown): data is Gender {
          return validateGender(data) === undefined
        }

        export function assertGender(data: unknown): asserts data is Gender {
          const issues = validateGender(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle type alias with literal', async () => {
    const code = `
    type Age = number
    type Gender = 'male' | 'female'
    export type Person = {
      age: Age
      gender: Gender | 'unknown'
    }
    export type User = Person
    `
    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "const AgeSchema = z.number()

      const GenderSchema = z.union([z.literal('male'), z.literal('female')])

      export const PersonSchema = z.object({
        age: AgeSchema,
        gender: z.union([GenderSchema, z.literal('unknown')]),
      })

      export const UserSchema = PersonSchema

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "Person",
            "schema": "PersonSchema",
          },
          {
            "interface": "User",
            "schema": "UserSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validatePerson(data: unknown): $ZodIssue[] | undefined {
          const result = PersonSchema.safeParse(data)
          return result.error?.issues
        }

        export function isPerson(data: unknown): data is Person {
          return validatePerson(data) === undefined
        }

        export function assertPerson(data: unknown): asserts data is Person {
          const issues = validatePerson(data)
          if (issues) throw issues
        }


        export function validateUser(data: unknown): $ZodIssue[] | undefined {
          const result = UserSchema.safeParse(data)
          return result.error?.issues
        }

        export function isUser(data: unknown): data is User {
          return validateUser(data) === undefined
        }

        export function assertUser(data: unknown): asserts data is User {
          const issues = validateUser(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle type alias with nested literal', async () => {
    const code = `
    type Age = number
    type Gender = 'male' | 'female'
    export type Person = {
      age: Age
      gender: Gender | 'unknown'
      address?: {
        city: string
        postalCode: string
      }
    }
    `
    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "const AgeSchema = z.number()

      const GenderSchema = z.union([z.literal('male'), z.literal('female')])

      export const PersonSchema = z.object({
        age: AgeSchema,
        gender: z.union([GenderSchema, z.literal('unknown')]),
        address: z.object({
        city: z.string(),
        postalCode: z.string(),
      }).optional(),
      })

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "Person",
            "schema": "PersonSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validatePerson(data: unknown): $ZodIssue[] | undefined {
          const result = PersonSchema.safeParse(data)
          return result.error?.issues
        }

        export function isPerson(data: unknown): data is Person {
          return validatePerson(data) === undefined
        }

        export function assertPerson(data: unknown): asserts data is Person {
          const issues = validatePerson(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  it('should handle type alias with intersection type', async () => {
    const code = `
    type Age = number
    type Gender = 'male' | 'female'
    type Contact = {
      email: string
    }
    type Tel = {
      areaCode?: string | null
      tel: string | undefined
    }
    type Address = {
      city: string
      postalCode: string
    }
    type PersonBase = {
      age: Age
      gender: Gender | 'unknown'
    }
    type PersonDetails = {
      address?: Address
      tel?: Tel | string | null
    }
    export type Person = PersonBase & PersonDetails & Contact
    `
    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "const AgeSchema = z.number()

      const GenderSchema = z.union([z.literal('male'), z.literal('female')])

      const PersonBaseSchema = z.object({
        age: AgeSchema,
        gender: z.union([GenderSchema, z.literal('unknown')]),
      })

      const AddressSchema = z.object({
        city: z.string(),
        postalCode: z.string(),
      })

      const TelSchema = z.object({
        areaCode: z.union([z.string(), z.null()]).optional(),
        tel: z.union([z.string(), z.undefined()]),
      })

      const PersonDetailsSchema = z.object({
        address: AddressSchema.optional(),
        tel: z.union([TelSchema, z.string(), z.null()]).optional(),
      })

      const ContactSchema = z.object({
        email: z.string(),
      })

      export const PersonSchema = z.intersection(z.intersection(PersonBaseSchema, PersonDetailsSchema), ContactSchema)

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "Person",
            "schema": "PersonSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validatePerson(data: unknown): $ZodIssue[] | undefined {
          const result = PersonSchema.safeParse(data)
          return result.error?.issues
        }

        export function isPerson(data: unknown): data is Person {
          return validatePerson(data) === undefined
        }

        export function assertPerson(data: unknown): asserts data is Person {
          const issues = validatePerson(data)
          if (issues) throw issues
        }"
      `)
    }
  })
  it('should handle type alias with intersection type 2', async () => {
    const code = `
    export type X = string & number
    export type Y = string & ( 'a' | 'b' )
    export type Z = string & {
      a: string
      b: number
    }
    export type W = ( 'a' | 'b' ) & ( 'b' | 'c' ) & 'b'
    `

    const result = await generate(code)
    expect(result).toMatchInlineSnapshot(`
      {
        "code": {
          "banner": "// generated by valype",
          "content": "export const WSchema = z.intersection(z.intersection(z.union([z.literal('a'), z.literal('b')]), z.union([z.literal('b'), z.literal('c')])), z.literal('b'))

      export const ZSchema = z.intersection(z.string(), z.object({
        a: z.string(),
        b: z.number(),
      }))

      export const YSchema = z.intersection(z.string(), z.union([z.literal('a'), z.literal('b')]))

      export const XSchema = z.intersection(z.string(), z.number())

      ",
          "imports": [
            "import { z } from 'zod/v4'",
          ],
        },
        "exports": [
          {
            "interface": "X",
            "schema": "XSchema",
          },
          {
            "interface": "Y",
            "schema": "YSchema",
          },
          {
            "interface": "Z",
            "schema": "ZSchema",
          },
          {
            "interface": "W",
            "schema": "WSchema",
          },
        ],
        "generateValidator": [Function],
        "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
      }
    `)

    if (!(result instanceof Error)) {
      expect(
        result.exports
          .map((e) => {
            const exports = result.generateValidator(e.interface, e.schema)
            return [
              exports.banner,
              exports.imports.join('\n'),
              exports.content,
            ].join('\n')
          })
          .join('\n'),
      ).toMatchInlineSnapshot(`
        "

        export function validateX(data: unknown): $ZodIssue[] | undefined {
          const result = XSchema.safeParse(data)
          return result.error?.issues
        }

        export function isX(data: unknown): data is X {
          return validateX(data) === undefined
        }

        export function assertX(data: unknown): asserts data is X {
          const issues = validateX(data)
          if (issues) throw issues
        }


        export function validateY(data: unknown): $ZodIssue[] | undefined {
          const result = YSchema.safeParse(data)
          return result.error?.issues
        }

        export function isY(data: unknown): data is Y {
          return validateY(data) === undefined
        }

        export function assertY(data: unknown): asserts data is Y {
          const issues = validateY(data)
          if (issues) throw issues
        }


        export function validateZ(data: unknown): $ZodIssue[] | undefined {
          const result = ZSchema.safeParse(data)
          return result.error?.issues
        }

        export function isZ(data: unknown): data is Z {
          return validateZ(data) === undefined
        }

        export function assertZ(data: unknown): asserts data is Z {
          const issues = validateZ(data)
          if (issues) throw issues
        }


        export function validateW(data: unknown): $ZodIssue[] | undefined {
          const result = WSchema.safeParse(data)
          return result.error?.issues
        }

        export function isW(data: unknown): data is W {
          return validateW(data) === undefined
        }

        export function assertW(data: unknown): asserts data is W {
          const issues = validateW(data)
          if (issues) throw issues
        }"
      `)
    }
  })

  describe('topological sorting', () => {
    it('should handle simple dependencies in correct order', async () => {
      const code = `
        interface A {
          b: B
        }
        
        interface B {
          value: string
        }
        
        export interface C {
          a: A
        }
      `

      const result = await generate(code)
      expect(result).not.toBeInstanceOf(Error)
      if (!(result instanceof Error)) {
        expect(result.code.content).toMatchInlineSnapshot(`
          "const BSchema = z.object({
            value: z.string(),
          })

          const ASchema = z.object({
            b: BSchema,
          })

          export const CSchema = z.object({
            a: ASchema,
          })

          "
        `)
      }
    })

    it('should handle nested dependencies in correct order', async () => {
      const code = `
        interface A {
          b: B
        }
        
        interface B {
          c: C
        }
        
        interface C {
          value: string
        }
        
        export interface D {
          a: A
        }
      `

      const result = await generate(code)
      expect(result).not.toBeInstanceOf(Error)
      if (!(result instanceof Error)) {
        expect(result.code.content).toMatchInlineSnapshot(`
          "const CSchema = z.object({
            value: z.string(),
          })

          const BSchema = z.object({
            c: CSchema,
          })

          const ASchema = z.object({
            b: BSchema,
          })

          export const DSchema = z.object({
            a: ASchema,
          })

          "
        `)
      }
    })

    it('should detect circular dependencies', async () => {
      const code = `
        interface A {
          b: B
        }
        
        interface B {
          a: A
        }
        
        export interface C {
          a: A
        }
      `

      const result = await generate(code)
      expect(result).toBeInstanceOf(Error)
      if (result instanceof Error) {
        expect(result.message).toContain('Circular dependency')
      }
    })

    it('should handle mixed exported/unexported dependencies', async () => {
      const code = `
        interface A {
          b: B
        }
        
        export interface B {
          value: string
        }
        
        export interface C {
          a: A
        }
      `

      const result = await generate(code)
      expect(result).not.toBeInstanceOf(Error)
      if (!(result instanceof Error)) {
        // 检查生成的代码顺序应该是 B -> A -> C
        expect(result.code.content).toMatchInlineSnapshot(`
          "export const BSchema = z.object({
            value: z.string(),
          })

          const ASchema = z.object({
            b: BSchema,
          })

          export const CSchema = z.object({
            a: ASchema,
          })

          "
        `)
        // 检查只有 B 和 C 被导出
        expect(result.exports.map((e) => e.interface)).toEqual(['B', 'C'])
      }
    })
  })

  describe('from production environment', () => {
    it('协同调阅', async () => {
      const code = `
export interface Data {
  /** 医疗机构 */
  medicalInstitution: {
    /** 名称 */
    name: string
    /** 代码 */
    code: string
    origin: string
    /** 登录 */
    login: {
      /** 用户名 */
      name: string
      /** 密码 */
      password: string
    }
  }

  /** 医生 */
  doctor: {
    /** 姓名 */
    name: string
    /**
     * 科室
     * @example "内科"
     */
    department: string
    /** 工号 */
    employeeId: string
  }

  /** 患者 */
  patient: {
    /** 身份证号 */
    idNo: string
    /** 姓名 */
    name: string
    /**
     * 年龄
     * @example "34"
     */
    age: string
    /**
     * 生理性别
     * @example "男" | "女"
     */
    sex: '男' | '女'
    /** 就诊号 */
    appointmentId: string
  }
}`

      const result = await generate(code)
      expect(result).toMatchInlineSnapshot(`
        {
          "code": {
            "banner": "// generated by valype",
            "content": "export const DataSchema = z.object({
          medicalInstitution: z.object({
          name: z.string(),
          code: z.string(),
          origin: z.string(),
          login: z.object({
          name: z.string(),
          password: z.string(),
        }),
        }),
          doctor: z.object({
          name: z.string(),
          department: z.string(),
          employeeId: z.string(),
        }),
          patient: z.object({
          idNo: z.string(),
          name: z.string(),
          age: z.string(),
          sex: z.union([z.literal('男'), z.literal('女')]),
          appointmentId: z.string(),
        }),
        })

        ",
            "imports": [
              "import { z } from 'zod/v4'",
            ],
          },
          "exports": [
            {
              "interface": "Data",
              "schema": "DataSchema",
            },
          ],
          "generateValidator": [Function],
          "validatorImport": "import { type $ZodIssue } from 'zod/v4/core'",
        }
      `)

      if (!(result instanceof Error)) {
        expect(
          result.exports
            .map((e) => {
              const exports = result.generateValidator(e.interface, e.schema)
              return [
                exports.banner,
                exports.imports.join('\n'),
                exports.content,
              ].join('\n')
            })
            .join('\n'),
        ).toMatchInlineSnapshot(`
          "

          export function validateData(data: unknown): $ZodIssue[] | undefined {
            const result = DataSchema.safeParse(data)
            return result.error?.issues
          }

          export function isData(data: unknown): data is Data {
            return validateData(data) === undefined
          }

          export function assertData(data: unknown): asserts data is Data {
            const issues = validateData(data)
            if (issues) throw issues
          }"
        `)
      }
    })
  })
})
