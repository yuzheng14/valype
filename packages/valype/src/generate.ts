import {
  parseAsync,
  ParseResult,
  parseSync,
  type Directive,
  type Statement,
} from 'oxc-parser'
import {
  extractSpan,
  ValypeCircularDependencyError,
  ValypeReferenceError,
  ValypeSyntaxError,
  ValypeUnimplementedError,
} from './error'
import { mapTSInterfaceDeclaration, mapTSTypeAliasDeclaration } from './map/map'
import {
  createGenerateContext,
  createTranslationContext,
  type DeclarationInfo,
  type TSDeclaration,
} from './context'
import { DepGraph } from './dependency'

export interface Export {
  /** interface name */
  interface: string
  /** schema name */
  schema: string
}

/** extract TS*Declaration from Statement */
function extractTSDeclaration(
  node: Directive | Statement,
): (TSDeclaration & Pick<DeclarationInfo, 'exported'>) | void {
  const decl = node.type === 'ExportNamedDeclaration' ? node.declaration : node

  if (
    decl?.type === 'TSInterfaceDeclaration' ||
    decl?.type === 'TSTypeAliasDeclaration'
  ) {
    return {
      ...decl,
      exported: node.type === 'ExportNamedDeclaration',
    }
  }
}

export interface Code {
  banner: string
  imports: string[]
  content: string
}

// FIXME refactor internal property
export interface GenerateResult {
  code: Code
  /** **[internal]** You should not use this. If you need it indeed, please issue it. */
  exports: Export[]
  /** **[internal]** You should not use this. If you need it indeed, please issue it. */
  validatorImport: string
  /** **[internal]** You should not use this. If you need it indeed, please issue it. */
  generateValidator(decl: string, schema?: string): Code
}

function createGenerateResult(): GenerateResult {
  return {
    code: {
      banner: '',
      imports: [],
      content: '',
    },
    exports: [],
    validatorImport: `import { type $ZodIssue } from 'zod/v4/core'`,
    generateValidator(decl, schema) {
      schema ??= `${decl}Schema`
      return {
        banner: '',
        imports: [],
        content: `export function validate${decl}(data: unknown): $ZodIssue[] | undefined {
  const result = ${schema}.safeParse(data)
  return result.error?.issues
}

export function is${decl}(data: unknown): data is ${decl} {
  return validate${decl}(data) === undefined
}

export function assert${decl}(data: unknown): asserts data is ${decl} {
  const issues = validate${decl}(data)
  if (issues) throw issues
}`,
      }
    },
  }
}

export type GenerateReturnValue =
  | GenerateResult
  | ValypeUnimplementedError
  | ValypeSyntaxError
  | ValypeReferenceError
  | ValypeCircularDependencyError

function internalGenerate(ast: ParseResult, code: string): GenerateReturnValue {
  const ctx = createGenerateContext(code)

  // collect all type declarations
  for (const stmt of ast.program.body) {
    const node = extractTSDeclaration(stmt)
    if (!node) continue

    const name = node.id.name

    if (ctx.decl.has(name))
      return new ValypeUnimplementedError(
        'interface merging',
        extractSpan(node),
      )

    const intfInfo: DeclarationInfo = {
      name,
      node,
      exported: node.exported,
    }
    ctx.decl.set(name, intfInfo)
    if (node.exported) ctx.exportedDecl.push({ name, span: extractSpan(node) })
  }

  const result = createGenerateResult()

  // There is no exported interface and no need to proceed
  if (ctx.exportedDecl.length === 0) return result

  result.code.banner = '// generated by valype'
  result.code.imports.push(`import { z } from 'zod/v4'`)

  const depGraph = new DepGraph()
  const pending = [...ctx.exportedDecl].reverse()
  while (pending.length) {
    // it should exist because loop could continue only when there is element in `pending`
    const dep = pending.pop()!
    const declInfo = ctx.decl.get(dep.name)

    if (!declInfo) return new ValypeReferenceError(dep.name, dep.span)

    // decl has been processed, skip
    if (depGraph.hasVertex(declInfo.name)) continue

    // transform declaration to schema
    const context = createTranslationContext()
    const declRaw =
      declInfo.node.type === 'TSTypeAliasDeclaration'
        ? mapTSTypeAliasDeclaration(declInfo.node, context)
        : mapTSInterfaceDeclaration(declInfo.node, context)
    if (declRaw instanceof Error) return declRaw

    const plainSchemaDecl = `const ${declInfo.name}Schema = ${declRaw}\n\n`

    depGraph.addVertex(declInfo.name, {
      ...declInfo,
      schemaCode: declInfo.exported
        ? `export ${plainSchemaDecl}`
        : plainSchemaDecl,
      dependencies: context.dependencies.map((d) => d.name),
    })

    if (declInfo.exported) {
      result.exports.push({
        interface: declInfo.name,
        schema: `${declInfo.name}Schema`,
      })
    }

    pending.push(...context.dependencies)
  }

  // generate code using topological sort
  const schemaCode = depGraph.generateCode()
  if (schemaCode instanceof Error) return schemaCode
  result.code.content = schemaCode

  return result
}

/**
 * convert TypeScript interface definitions to Zod schema
 * @param code content of typeScript file
 * @returns generated Zod schema code as a string
 */
export async function generate(code: string): Promise<GenerateReturnValue> {
  const ast = await parseAsync('temp.ts', code)

  return internalGenerate(ast, code)
}

/**
 * convert TypeScript interface definitions to Zod schema synchronously
 * @param code content of typeScript file
 * @returns generated Zod schema code as a string
 */
export function generateSync(code: string): GenerateReturnValue {
  const ast = parseSync('temp.ts', code)

  return internalGenerate(ast, code)
}
