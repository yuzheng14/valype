import { parseAsync, type Directive, type Statement } from 'oxc-parser'
import {
  extractSpan,
  ValypeReferenceError,
  ValypeSyntaxError,
  ValypeUnimplementedError,
} from './error'
import { mapTSInterfaceDeclaration, mapTSTypeAliasDeclaration } from './map/map'
import {
  createGenerateContext,
  createTranslationContext,
  type DeclarationInfo,
  type TSDeclaration,
} from './context'

export interface Export {
  /** interface name */
  interface: string
  /** schema name */
  schema: string
}

/** extract TS*Declaration from Statement */
function extractTSDeclaration(
  node: Directive | Statement,
): (TSDeclaration & Pick<DeclarationInfo, 'exported'>) | void {
  const decl = node.type === 'ExportNamedDeclaration' ? node.declaration : node

  if (
    decl?.type === 'TSInterfaceDeclaration' ||
    decl?.type === 'TSTypeAliasDeclaration'
  ) {
    return {
      ...decl,
      exported: node.type === 'ExportNamedDeclaration',
    }
  }
}

export interface GenerateResult {
  code: string
  /** **[internal]** You should not use this. If you need it indeed, please issue it. */
  exports: Export[]
}

/**
 * convert TypeScript interface definitions to Zod schema
 * @param code content of typeScript file
 * @returns generated Zod schema code as a string
 */
export async function generate(
  code: string,
): Promise<
  | GenerateResult
  | ValypeUnimplementedError
  | ValypeReferenceError
  | ValypeSyntaxError
> {
  const ast = await parseAsync('temp.ts', code)

  const ctx = createGenerateContext(code)

  // collect all interface declarations
  for (const stmt of ast.program.body) {
    const node = extractTSDeclaration(stmt)
    if (!node) continue

    const name = node.id.name

    if (ctx.decl.has(name))
      return new ValypeUnimplementedError(
        'interface merging',
        extractSpan(node),
      )

    const intfInfo = {
      name,
      node,
      exported: node.exported,
    }
    ctx.decl.set(name, intfInfo)
    if (node.exported) ctx.pending.push(intfInfo)
  }

  // There is no exported interface and no need to proceed
  if (ctx.pending.length === 0)
    return { code: '', exports: [] } satisfies GenerateResult

  const result: GenerateResult = {
    code: `// generated by valype\nimport { z } from 'zod/v4'\n\n`,
    exports: [],
  }

  const chunks: string[] = []
  let pending = ''
  while (true) {
    const declInfo = ctx.pending.shift()

    if (!declInfo) break
    if (ctx.processed.has(declInfo.name)) continue

    const context = createTranslationContext()
    const declRaw =
      declInfo.node.type === 'TSTypeAliasDeclaration'
        ? mapTSTypeAliasDeclaration(declInfo.node, context)
        : mapTSInterfaceDeclaration(declInfo.node, context)
    if (declRaw instanceof Error) return declRaw
    ctx.processed.add(declInfo.name)

    const decl = `const ${declInfo.name}Schema = ${declRaw}\n\n`
    const wrappedDecl = declInfo.exported ? `export ${decl}` : decl
    if (declInfo.exported) {
      result.exports.push({
        interface: declInfo.name,
        schema: `${declInfo.name}Schema`,
      })
      // flush previous pending before exported item
      chunks.push(pending)
      pending = ''
    }

    pending = wrappedDecl + pending

    const span = extractSpan(declInfo.node)
    for (const ref of context.dependencies) {
      if (ctx.processed.has(ref)) continue
      const intfInfo = ctx.decl.get(ref)
      if (!intfInfo) return new ValypeReferenceError(ref, span)
      if (intfInfo.exported) continue
      ctx.pending.unshift(intfInfo)
    }
  }

  chunks.push(pending)
  result.code += chunks.join('')

  return result
}
