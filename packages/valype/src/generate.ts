import {
  parseAsync,
  ParseResult,
  parseSync,
  type Directive,
  type Statement,
} from 'oxc-parser'
import {
  extractSpan,
  ValypeReferenceError,
  ValypeSyntaxError,
  ValypeUnimplementedError,
} from './error'
import { mapTSInterfaceDeclaration, mapTSTypeAliasDeclaration } from './map/map'
import {
  createGenerateContext,
  createTranslationContext,
  type DeclarationInfo,
  type GenerateContext,
  type TSDeclaration,
} from './context'

export interface Export {
  /** interface name */
  interface: string
  /** schema name */
  schema: string
}

/** extract TS*Declaration from Statement */
function extractTSDeclaration(
  node: Directive | Statement,
): (TSDeclaration & Pick<DeclarationInfo, 'exported'>) | void {
  const decl = node.type === 'ExportNamedDeclaration' ? node.declaration : node

  if (
    decl?.type === 'TSInterfaceDeclaration' ||
    decl?.type === 'TSTypeAliasDeclaration'
  ) {
    return {
      ...decl,
      exported: node.type === 'ExportNamedDeclaration',
    }
  }
}

export interface Code {
  banner: string
  imports: string[]
  content: string
}

// FIXME refactor internal property
export interface GenerateResult {
  code: Code
  /** **[internal]** You should not use this. If you need it indeed, please issue it. */
  exports: Export[]
  /** **[internal]** You should not use this. If you need it indeed, please issue it. */
  validatorImport: string
  /** **[internal]** You should not use this. If you need it indeed, please issue it. */
  generateValidator(decl: string, schema?: string): Code
}

function createGenerateResult(): GenerateResult {
  return {
    code: {
      banner: '',
      imports: [],
      content: '',
    },
    exports: [],
    validatorImport: `import { type $ZodIssue } from 'zod/v4/core'`,
    generateValidator(decl, schema) {
      schema ??= `${decl}Schema`
      return {
        banner: '',
        imports: [],
        content: `export function validate${decl}(data: unknown): $ZodIssue[] | undefined {
  const result = ${schema}.safeParse(data)
  return result.error?.issues
}

export function is${decl}(data: unknown): data is ${decl} {
  return validate${decl}(data) === undefined
}

export function assert${decl}(data: unknown): asserts data is ${decl} {
  const issues = validate${decl}(data)
  if (issues) throw issues
}`,
      }
    },
  }
}

function internalGenerate(
  ast: ParseResult,
  ctx: GenerateContext,
):
  | GenerateResult
  | ValypeUnimplementedError
  | ValypeSyntaxError
  | ValypeReferenceError {
  // collect all interface declarations
  for (const stmt of ast.program.body) {
    const node = extractTSDeclaration(stmt)
    if (!node) continue

    const name = node.id.name

    if (ctx.decl.has(name))
      return new ValypeUnimplementedError(
        'interface merging',
        extractSpan(node),
      )

    const intfInfo = {
      name,
      node,
      exported: node.exported,
    }
    ctx.decl.set(name, intfInfo)
    if (node.exported) ctx.pending.push(intfInfo)
  }

  const result = createGenerateResult()

  // There is no exported interface and no need to proceed
  if (ctx.pending.length === 0) return result

  result.code.banner = '// generated by valype'
  result.code.imports.push(`import { z } from 'zod/v4'`)

  const chunks: string[] = []
  let pending = ''
  while (true) {
    const declInfo = ctx.pending.shift()

    if (!declInfo) break
    if (ctx.processed.has(declInfo.name)) continue

    const context = createTranslationContext()
    const declRaw =
      declInfo.node.type === 'TSTypeAliasDeclaration'
        ? mapTSTypeAliasDeclaration(declInfo.node, context)
        : mapTSInterfaceDeclaration(declInfo.node, context)
    if (declRaw instanceof Error) return declRaw
    ctx.processed.add(declInfo.name)

    const decl = `const ${declInfo.name}Schema = ${declRaw}\n\n`
    const wrappedDecl = declInfo.exported ? `export ${decl}` : decl
    if (declInfo.exported) {
      result.exports.push({
        interface: declInfo.name,
        schema: `${declInfo.name}Schema`,
      })
      // flush previous pending before exported item
      chunks.push(pending)
      pending = ''
    }

    pending = wrappedDecl + pending

    const span = extractSpan(declInfo.node)
    for (const ref of context.dependencies) {
      if (ctx.processed.has(ref)) continue
      const intfInfo = ctx.decl.get(ref)
      if (!intfInfo) return new ValypeReferenceError(ref, span)
      if (intfInfo.exported) continue
      ctx.pending.unshift(intfInfo)
    }
  }

  chunks.push(pending)
  result.code.content += chunks.join('')

  return result
}

/**
 * convert TypeScript interface definitions to Zod schema
 * @param code content of typeScript file
 * @returns generated Zod schema code as a string
 */
export async function generate(
  code: string,
): Promise<
  | GenerateResult
  | ValypeUnimplementedError
  | ValypeReferenceError
  | ValypeSyntaxError
> {
  const ast = await parseAsync('temp.ts', code)

  const ctx = createGenerateContext(code)

  return internalGenerate(ast, ctx)
}

/**
 * convert TypeScript interface definitions to Zod schema synchronously
 * @param code content of typeScript file
 * @returns generated Zod schema code as a string
 */
export function generateSync(
  code: string,
):
  | GenerateResult
  | ValypeUnimplementedError
  | ValypeReferenceError
  | ValypeSyntaxError {
  const ast = parseSync('temp.ts', code)

  const ctx = createGenerateContext(code)

  return internalGenerate(ast, ctx)
}
